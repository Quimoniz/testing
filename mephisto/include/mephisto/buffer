#ifndef MEPHISTO_DETAIL_META
#define MEPHISTO_DETAIL_META
#include <alpaka/alpaka.hpp>

#include <mephisto/array>
#include <mephisto/type_traits>
#include <type_traits>

#include <iostream>

namespace mephisto {

/**
 * Information about a local chunk of memory and its coordinates relative to
 * the global origin.
 */
template <typename ViewSpec>
struct Metadata {
  ViewSpec _viewspec;

  Metadata(ViewSpec viewspec)
    : _viewspec(viewspec)
  {
  }

  ALPAKA_FN_HOST_ACC
  auto offsets() const
  {
    return _viewspec.offsets();
  }

  ALPAKA_FN_HOST_ACC
  auto extents() const
  {
    return _viewspec.extents();
  }

  ALPAKA_FN_HOST_ACC
  auto size() const
  {
    return _viewspec.size();
  }
};

template <
    typename Element,
    typename Entity,
    typename ViewSpec,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
struct DeviceDataBuffer {

  using Meta = Metadata<ViewSpec>;


  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;
  Element *_data;
  void *   _base;

  DeviceDataBuffer(Entity ent, void *base)
    : _base(base)
    , _data(reinterpret_cast<char *>(base) + MetaOffset)
  {
  }

  ALPAKA_FN_HOST_ACC
  const Meta &meta() const
  {
    // get the memory MetaOffset bytes before data
    return *reinterpret_cast<Meta *>(_base);
  }

  ALPAKA_FN_HOST_ACC
  const Meta meta_view() const {
    return alpaka::mem::view::createStaticDevMemView(
        meta(), host(), static_cast<std::size_t>(1));
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *begin()
  {
    return data;
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *end() const
  {
    return begin() + meta().size();
  }
};

/**
 * Data buffer is used to reduce the number of parameters to avoid hitting the 256 byte
 * limit.
 *
 * buf[[meta]..<padding>..[data...]]
 *
 */
template <
    typename Element,
    typename Device,
    typename ViewSpec,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
class HostDataBuffer {
  using NonConstElement   = typename std::remove_const<Element>::type;
  using Host              = alpaka::dev::DevCpu;
  using Meta              = Metadata<ViewSpec>;
  using Dim               = alpaka::dim::DimInt<Device::NDim>;
  using Idx               = std::size_t;
  using DeviceBuf =
      DeviceDataBuffer<NonConstElement, Device, Meta, Alignment>;
  using HostBuf =
      alpaka::mem::view::ViewPlainPtr<Host, Element, Dim, std::size_t>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *   _begin;
  std::size_t _bufsize;
  std::size_t _nelems;
  Meta        _meta;
  HostBuf     _hostbuf;

public:
  HostDataBuffer(
      ViewSpec viewspec,
      const Element *  begin)
    : _begin(begin)
    , _meta(viewspec)
    , _nelems(viewspec.size())
    , _bufsize(sizeof(Meta) + _nelems * sizeof(Element) + Alignment::value)
    , _hostbuf(begin, host(), _nelems)
  { }

  // TODO: extract into proper allocator?
  template <typename Entity>
  auto alloc_entity_buf(Entity &entity)
  {
    // Return a newly created and allocated buffer
    using EntityBuffer = DeviceDataBuffer<Element, Entity, ViewSpec>;
    return EntityBuffer{entity,
                        alpaka::mem::view::getPtrNative(
                            alpaka::mem::buf::alloc<char, std::size_t>(
                                entity.device(), _bufsize))};
  }

  template <typename Entity>
  DeviceBuf getDeviceDataBuffer(Entity &entity)
  {
    auto accBuf = alpaka::mem::view::getPtrNative(entity.deviceBuf);
    // Add MetaOffset bytes offset to the accBuf address */
    auto deviceBufAddr = reinterpret_cast<NonConstElement *>(
        reinterpret_cast<char *>(accBuf) + MetaOffset);
    return DeviceBuf(deviceBufAddr);
  }

  Meta *meta() const
  {
    return _meta;
  }

  Element *data() const

  {
    return _begin;
  }

  auto host() const
  {
    return Host{alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u)};
  }

  /* auto getDeviceMetaView() */
  /* { */
  /*   auto devicePtr = alpaka::mem::view::getPtrNative(deviceBuf); */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, Meta, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<Meta *>(devicePtr), context.accDevice,
   * static_cast<std::size_t>(1)); */
  /* } */

  auto meta_view() const
  {
    return alpaka::mem::view::createStaticDevMemView(
        &_meta, host(), static_cast<std::size_t>(1));
  }

  /* auto getDeviceDataView() */
  /* { */
  /* //, deviceBuf( */
  /*  //     alpaka::mem::buf::alloc<char, size_t>(context.accDevice,
   * bufsize)) */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, NonConstElement, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<NonConstElement *>( */
  /*           reinterpret_cast<char *>( */
  /*               alpaka::mem::view::getPtrNative(deviceBuf)) + */
  /*           MetaOffset), */
  /*       context.accDevice, static_cast<std::size_t>(datasize)); */
  /* } */

  HostBuf &data_view() const
  {
    return alpaka::mem::view::createStaticDevMemView(
        data(), host(), _meta.size());
  }

  size_t datasize() const {
    return _nelems * sizeof(Element);
  }

  size_t nelems() const {
    return _nelems;
  }

  size_t bufsize() const {
    return _bufsize;
  }
};

}  // namespace mephisto

#endif
