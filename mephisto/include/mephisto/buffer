#ifndef MEPHISTO_DETAIL_META
#define MEPHISTO_DETAIL_META
#include <alpaka/alpaka.hpp>

#include <mephisto/array>
#include <mephisto/type_traits>
#include <type_traits>

#include <iostream>

namespace mephisto {

/**
 * Information about a local chunk of memory and its coordinates relative to
 * the global origin.
 */
template <typename ViewSpec>
struct Metadata {
  ViewSpec _viewspec;

  Metadata(ViewSpec viewspec)
    : _viewspec(viewspec)
  {
  }

  ALPAKA_FN_HOST_ACC
  auto offsets() const
  {
    return _viewspec.offsets();
  }

  ALPAKA_FN_HOST_ACC
  auto extents() const
  {
    return _viewspec.extents();
  }

  ALPAKA_FN_HOST_ACC
  auto size() const
  {
    return _viewspec.size();
  }
};

template <
    typename Element,
    typename Entity,
    typename ViewSpec,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
struct DeviceDataBuffer {
  using Meta     = Metadata<ViewSpec>;
  using device_t = typename entity_traits::device<Entity>::type;
  using acc_t = typename entity_traits::acc<Entity>::type;

  // We need to save the PlainPtr views here, so we don't have to keep an
  // instance of the device here, too.
  using meta_view_t = alpaka::mem::view::ViewPlainPtr<
      acc_t,
      Meta,
      alpaka::dim::DimInt<1>,
      std::size_t>;
  using data_view_t = alpaka::mem::view::
      ViewPlainPtr<Element *, device_t, int, ViewSpec>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *_data;
  void *   _base;
  std::size_t _entity_index;

  DeviceDataBuffer(Entity ent, Element *base)

    : _base(base)
    , _entity_index(ent.index())
    , _data(reinterpret_cast<Element *>(
          reinterpret_cast<char *>(base) + MetaOffset))
  {
  }

  ALPAKA_FN_HOST_ACC
  const Meta &meta() const
  {
    // get the memory MetaOffset bytes before data
    return *reinterpret_cast<Meta *>(_base);
  }

  ALPAKA_FN_HOST_ACC
  const Meta meta_view() const {
    return alpaka::mem::view::createStaticDevMemView(
        meta(), entity().device(), static_cast<std::size_t>(1));
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *begin()
  {
    return _data;
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *end() const
  {
    return begin() + meta().size();
  }

  Entity entity() {
    return Entity(_entity_index);
  }
};

/**
 * Data buffer is used to reduce the number of parameters to avoid hitting the 256 byte
 * limit.
 *
 * buf[[meta]..<padding>..[data...]]
 *
 */
template <
    typename Element,
    typename Device,
    typename ViewSpec,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
class HostDataBuffer {
  using NonConstElement   = typename std::remove_const<Element>::type;
  using Host              = alpaka::dev::DevCpu;
  using Meta              = Metadata<ViewSpec>;
  using Dim               = alpaka::dim::DimInt<Device::NDim>;
  using Idx               = std::size_t;
  using DeviceBuf =
      DeviceDataBuffer<NonConstElement, Device, Meta, Alignment>;
  using HostBuf =
      alpaka::mem::view::ViewPlainPtr<Host, NonConstElement, Dim, Idx>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *      _begin;
  std::size_t    _nelems;
  std::size_t    _bufsize;
  Meta           _meta;

public:
  HostDataBuffer(
      ViewSpec viewspec,
      Element *  begin)
    : _begin(begin)
    , _meta(viewspec)
    , _nelems(viewspec.size())
    , _bufsize(sizeof(Meta) + _nelems * sizeof(Element) + Alignment::value)
  { }

  // TODO: extract into proper allocator?
  template <typename Entity>
  auto alloc_entity_buf(Entity &entity)
  {
    // Return a newly created and allocated buffer
    using EntityBuffer = DeviceDataBuffer<NonConstElement, Entity, ViewSpec>;
    auto buf =
        alpaka::mem::buf::alloc<char, std::size_t>(entity.device(), _bufsize);
    return EntityBuffer{entity,
                        reinterpret_cast<NonConstElement *>(
                            alpaka::mem::view::getPtrNative(buf))};
  }

  template <typename Entity>
  DeviceBuf getDeviceDataBuffer(Entity &entity)
  {
    auto accBuf = alpaka::mem::view::getPtrNative(entity.deviceBuf);
    // Add MetaOffset bytes offset to the accBuf address */
    auto deviceBufAddr = reinterpret_cast<NonConstElement *>(
        reinterpret_cast<char *>(accBuf) + MetaOffset);
    return DeviceBuf(deviceBufAddr);
  }

  const Meta *meta() const
  {
    return &_meta;
  }

  Element *data() const

  {
    return _begin;
  }

  auto host() const
  {
    return Host{alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u)};
  }

  /* auto getDeviceMetaView() */
  /* { */
  /*   auto devicePtr = alpaka::mem::view::getPtrNative(deviceBuf); */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, Meta, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<Meta *>(devicePtr), context.accDevice,
   * static_cast<std::size_t>(1)); */
  /* } */

  auto meta_view() const
  {
    return alpaka::mem::view::createStaticDevMemView(
        &_meta, host(), static_cast<std::size_t>(1));
  }

  /* auto getDeviceDataView() */
  /* { */
  /* //, deviceBuf( */
  /*  //     alpaka::mem::buf::alloc<char, size_t>(context.accDevice,
   * bufsize)) */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, NonConstElement, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<NonConstElement *>( */
  /*           reinterpret_cast<char *>( */
  /*               alpaka::mem::view::getPtrNative(deviceBuf)) + */
  /*           MetaOffset), */
  /*       context.accDevice, static_cast<std::size_t>(datasize)); */
  /* } */

  HostBuf &data_view() const
  {
    return alpaka::mem::view::createStaticDevMemView(
        data(), host(), _meta.size());
  }

  size_t datasize() const {
    return _nelems * sizeof(Element);
  }

  size_t nelems() const {
    return _nelems;
  }

  size_t bufsize() const {
    return _bufsize;
  }
};

}  // namespace mephisto

#endif
