#ifndef MEPHISTO_VIEWS
#define MEPHISTO_VIEWS

#include <llama/llama.hpp>

#include <mephisto/container>

namespace mephisto {

namespace view {

namespace details {

/* ALPAKA CODE BEGIN */

namespace internal
{

/// Accessor for a alpaka buffer using `getNativePtr`
template < typename T_Buffer >
struct AlpakaAccessor
{
    using PrimType = unsigned char;
    using BlobType = T_Buffer;

    AlpakaAccessor( BlobType buffer ) :
        buffer ( buffer )
    { }

    /* Explicit copy and move constructor and destructor definition because of
     * "calling a __host__ function from a __host__ __device__ function warnings
     * from nvidia compiler.
     */
    AlpakaAccessor( AlpakaAccessor const & ) = default;
    AlpakaAccessor( AlpakaAccessor && ) = default;
    ~AlpakaAccessor( ) = default;

    template< typename T_IndexType >
    auto
    operator[] ( T_IndexType && idx )
    -> PrimType &
    {
        return alpaka::mem::view::getPtrNative( buffer )[ idx ];
    }

    template< typename T_IndexType >
    auto operator[] ( T_IndexType && idx ) const
    -> const PrimType &
    {
        return alpaka::mem::view::getPtrNative( buffer )[ idx ];
    }

    BlobType buffer;
};

} // namespace internal

/** Allocator to allocate memory for a \ref llama::View in the
 *  \ref llama::Factory using `alpaka::mem::buf::Buf` in the background. The
 *  view created with this allocator can only be used on the host side. For the
 *  use of the view on the device see \ref AlpakaMirror.
 * \tparam T_DevAcc alpaka `DevAcc`
 * \tparam T_Size alpaka size type
 * \see AlpakaMirror
 */
template<
    typename T_DevAcc,
    typename T_Size
>
struct Alpaka
{
    using DevAcc = T_DevAcc;
    using Size = T_Size;

    using BufferType = alpaka::mem::buf::Buf<
        DevAcc,
        unsigned char,
        alpaka::dim::DimInt< 1 >,
        Size
    >;
    /** blob type of this allocator is an internal accessor the the alpaka
     *  buffer
     */
    using BlobType = internal::AlpakaAccessor< BufferType >;
    /// primary type of this allocator is `unsigned char`
    using PrimType = typename BlobType::PrimType;
    /// the parameter is the alpaka `DevAcc` instance
    using Parameter = DevAcc;

    static inline
    auto
    allocate(
        std::size_t count,
        Parameter devAcc
    )
    -> BlobType
    {
        BufferType buffer =
        alpaka::mem::buf::alloc<
            PrimType,
            Size
        > (
            devAcc,
            Size(count)
        );
#if defined(ALPAKA_ACC_GPU_CUDA_ENABLED) && BOOST_LANG_CUDA
        alpaka::mem::buf::pin( buffer );
#endif
        BlobType accessor( buffer );
        return accessor;
    }
};

/** Allocator to mirror the pointer of an \ref Alpaka allocated memory
 *  for a \ref llama::View in the \ref llama::Factory. The view created with
 *  this allocator can be used on the device side, but the memory is shared with
 *  the given view allocated with \ref Alpaka.
 * \tparam T_DevAcc alpaka `DevAcc`
 * \tparam T_Size alpaka size type
 * \tparam T_Mapping mapping used for creating the already existing view
 * \see Alpaka
 */
template<
    typename T_DevAcc,
    typename T_Size,
    typename T_Mapping
>
struct AlpakaMirror
{
    using MirroredAllocator = Alpaka<
        T_DevAcc,
        T_Size
    >;
    /// blob type of this allocator is `unsigned char*`
    using BlobType = typename MirroredAllocator::PrimType*;
    /// primary type of this allocator is `unsigned char`
    using PrimType = typename MirroredAllocator::PrimType;
    using MirroredView = llama::View<
        T_Mapping,
        typename MirroredAllocator::BlobType
    >;
    /// the parameter is the view which shall be mirrored
    using Parameter = MirroredView;

    static inline
    auto
    allocate(
        std::size_t count,
        Parameter mirroredView
    )
    -> BlobType
    {
        return alpaka::mem::view::getPtrNative( mirroredView.blob[0].buffer );
    }
};

/** Allocator to allocate memory for a \ref llama::View in the
 *  \ref llama::Factory using alpaka shared memory in the background. The view
 *  created with this allocator can only be used on the view side as share
 *  memory exists only there.
 * \tparam T_Acc alpaka `Acc` type of the kernel
 * \tparam T_count Amount of memory needed in byte like needed for
 * \ref llama::allocator::Stack at compile time. In the future this may change
 *  and be a run time parameter (at least for dynamic shared memory allocation).
 * \tparam T_uniqueID at compile time unique ID needed by alpaka, best is to use
 *  e.g. `__COUNTER__` which is always unique as it increases after each use
 *  while preprocessing the code.
 * \see llama::allocator::Stack
 */
template<
    typename T_Acc,
    std::size_t T_count,
    std::size_t T_uniqueID
>
struct AlpakaShared
{
    /// blob type of this allocator is `unsigned char*`
    using BlobType = unsigned char*;
    /// primary type of this allocator is `unsigned char`
    using PrimType = unsigned char;
    /// the allocation parameter is the alpaka `Acc` type of the kernel
    using Parameter = T_Acc;
    using AllocType = PrimType[ T_count ];

    static
    LLAMA_FN_HOST_ACC_INLINE
    auto
    allocate(
        std::size_t count,
        Parameter const & acc
    )
    -> BlobType
    {
        return alpaka::block::shared::st::allocVar<
            AllocType,
            T_uniqueID
        >( acc );

    }
};
/* ALPAKA CODE END */



template<
    typename T_Dev,
    typename T_Size
>
struct AlpakaPlainPtr
{
    using Dev = T_Dev;
    using Size = T_Size;

    using ViewType = alpaka::mem::view::ViewPlainPtr<
        Dev,
        unsigned char,
        alpaka::dim::DimInt< 1 >,
        Size
    >;
    /** blob type of this allocator is an internal accessor the the alpaka
     *  buffer
     */
    using BlobType = internal::AlpakaAccessor< ViewType >;
    /// primary type of this allocator is `unsigned char`
    using PrimType = typename BlobType::PrimType;
    /// the parameter is the alpaka `DevAcc` instance
    using Parameter = std::pair<Dev, unsigned char*>;

    static inline
    auto
    allocate(
        std::size_t count,
        Parameter params
    )
    -> BlobType
    {
        ViewType view(
            params.second,
            params.first,
            Size(count)
        );
        BlobType accessor( view );
        return accessor;
    }
};








} /* details */
template<
  typename ContainerT
  >
struct factory
{
    using size_type = std::size_t;
    using container_type = ContainerT;
    container_type& myContainer;
    factory(container_type& container): myContainer(container) {
    }
    template<
        typename DevT
    >
    auto
    create_local_view(DevT& dev)
    -> llama::View<
        typename container_type::value_type::mapping_type,
        typename details::AlpakaPlainPtr<std::remove_const_t<DevT>, size_type>::BlobType
    >
    {
        using container_value_type     = typename container_type::value_type;
        using container_factory_type   = typename container_value_type::container_factory_type;
        using container_container_type = typename container_value_type::container_type;
        using mapping_type             = typename container_value_type::mapping_type;
        using user_domain_type         = typename mapping_type::UserDomain;
        using datum_domain_type        = typename mapping_type::DatumDomain;

        using factory = llama::Factory<
            mapping_type,
            details::AlpakaPlainPtr<
                std::remove_const_t<DevT>,
                size_type
            >
        >;
        auto user_domain = container_factory_type::extent(myContainer);
        auto mapping = mapping_type(user_domain);

        return factory::allocView(mapping, std::make_pair(dev, reinterpret_cast<unsigned char*>(container_factory_type::data(myContainer))));
    }
    template<
        typename DevT
    >
    auto
    create_dev_view(DevT& devAcc)
    -> llama::View <
        typename ContainerT::value_type::mapping_type,
        typename details::Alpaka<std::remove_const_t<DevT>, size_type>::BlobType
    >
    
    {
        using dev_type = std::remove_const_t<DevT>; /* DO NOT PUT A `typename` HERE
                                   * "The typename is not needed there, and is therefore not allowed. "
                                   *  https://stackoverflow.com/a/6489381 */
        using container_value_type     = typename container_type::value_type;
        using container_factory_type   = typename container_value_type::container_factory_type;
        using container_container_type = typename container_value_type::container_type;
        using mapping_type             = typename container_value_type::mapping_type;
        using user_domain_type         = typename mapping_type::UserDomain;
        auto user_domain = container_factory_type::extent(myContainer);
        auto mapping = mapping_type(user_domain);

        using alpakaAllocator = details::Alpaka<
                dev_type,
                size_type
            >;

        using factory = llama::Factory<
            mapping_type,
            alpakaAllocator
        >;
        
        return factory::allocView(mapping, devAcc);
    }
    template<
        typename DevT,
        typename HostViewT
    >
    auto
    create_dev_view(DevT& devAcc, HostViewT& hostView)
    -> llama::View <
        typename ContainerT::value_type::mapping_type,
        typename details::Alpaka<std::remove_const_t<DevT>, size_type>::BlobType
    >
    
    {
        using dev_type = std::remove_const_t<DevT>; /* DO NOT PUT A `typename` HERE
                                   * "The typename is not needed there, and is therefore not allowed. "
                                   *  https://stackoverflow.com/a/6489381 */
        using container_value_type     = typename container_type::value_type;
        using container_factory_type   = typename container_value_type::container_factory_type;
        using container_container_type = typename container_value_type::container_type;
        using mapping_type             = typename container_value_type::mapping_type;
        using user_domain_type         = typename mapping_type::UserDomain;

        using alpakaAllocator = details::Alpaka<
                dev_type,
                size_type
            >;

        using factory = llama::Factory<
            mapping_type,
            alpakaAllocator
        >;
        
        return factory::allocView(hostView.mapping, devAcc);
    }
    template <
      typename DeviceAccT,
      typename DeviceViewT
    >
    auto
    create_mirror_view(DeviceAccT& devAcc, DeviceViewT& devView)
    -> llama::View <
        typename ContainerT::value_type::mapping_type,
        typename details::AlpakaMirror<
          std::remove_const_t<DeviceAccT>,
          size_type,
          typename container_type::value_type::mapping_type
        >::BlobType
    >
    {
        using container_value_type     = typename container_type::value_type;
        using container_factory_type   = typename container_value_type::container_factory_type;
        using container_container_type = typename container_value_type::container_type;
        using mapping_type             = typename container_value_type::mapping_type;
        using user_domain_type         = typename mapping_type::UserDomain;
        using non_const_dev_acc        = std::remove_const_t<DeviceAccT>;
        using alpakaMirror = details::AlpakaMirror<
          non_const_dev_acc,
          size_type,
          mapping_type
        >;
        using factory = llama::Factory<
          mapping_type,
          alpakaMirror
        >;
        return factory::allocView(devView.mapping, devView);
    }
};

template <
  typename ContainerT
>
auto make_factory(ContainerT& container)
-> factory<ContainerT>
{
    return std::move(factory<ContainerT>(container));
}

} /* view */

} /* mephisto */

#endif /* MEPHISTO_CONTAINER */
